package main

/*Реализовать постоянную запись данных в канал (главный поток). Реализовать набор из N воркеров,
которые читают произвольные данные из канала и выводят в stdout.
Необходима возможность выбора количества воркеров при старте.
Программа должна завершаться по нажатию Ctrl+C. Выбрать и обосновать способ завершения работы всех воркеров.
*/

import (
	"fmt"
	"os"
	"os/signal"
	"sync"
	"syscall"
	"time"
)

// Воркер, который обрабатывает данные из канала
func worker(id int, ch <-chan int, wg *sync.WaitGroup, done <-chan struct{}) {
	defer wg.Done() // Гарантируем уменьшение счетчика группы ожидания при выходе воркера
	for {
		select { // Ожидание данных из канала или сигнала завершения
		case data, ok := <-ch: // Получение данных из канала
			if !ok {
				// Если канал закрыт, воркер завершает работу.
				fmt.Printf("Воркер %d завершает работу...\n", id)
				return
			}
			// Вывод полученных данных.
			fmt.Printf("Воркер %d получил данные: %d\n", id, data)
		case <-done: // Если пришел сигнал на завершение работы...
			// Уведомляем о завершении работы воркера.
			fmt.Printf("Воркер %d получил сигнал на завершение работы...\n", id)
			return
		}
	}
}

func main() {
	ch := make(chan int)        // Создаем канал для передачи данных между воркерами и продьюсером
	done := make(chan struct{}) // Канал для посылки сигнала о завершении работы воркерам
	var wg sync.WaitGroup       // Используем группу ожидания для синхронизации завершения воркеров

	var workerCount int // Переменная для количества воркеров
	fmt.Print("Введите количество воркеров: ")
	fmt.Scan(&workerCount) // Получаем от пользователя количество воркеров

	signalChan := make(chan os.Signal, 1)                    // Канал для приема системных сигналов
	signal.Notify(signalChan, os.Interrupt, syscall.SIGTERM) // Настраиваем обработку сигналов Interrupt и SIGTERM

	// Запускаем воркеров
	for i := 1; i <= workerCount; i++ {
		wg.Add(1)                   // Увеличиваем счетчик в группе ожидания
		go worker(i, ch, &wg, done) // Запускаем воркера
	}

	// Передача данных в канал
	go func() {
		for i := 0; i < 20; i++ {
			select {
			case <-done: // Если пришел сигнал завершения, прекращаем отправку данных
				return
			default: // В обычном режиме продолжаем работу
				ch <- i // Отправляем данные каждую секунду
				time.Sleep(time.Second)
			}
		}
		close(ch) // Завершаем передачу данных, закрыв канал
	}()

	// Обработка сигнала Ctrl+C
	go func() {
		<-signalChan // Ждем сигнала
		close(done)  // Закрываем канал done, чтобы сказать воркерам остановиться
	}()

	// Ожидание завершения всех воркеров
	wg.Wait()
	fmt.Println("Программа завершила работу.") // Уведомление о завершении работы программы
}
